{"ast":null,"code":"import _objectSpread from \"C:/Users/Admin/Desktop/enisi/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n/* [@simplewebauthn/browser@10.0.0] */\nfunction bufferToBase64URLString(buffer) {\n  const bytes = new Uint8Array(buffer);\n  let str = '';\n  for (const charCode of bytes) {\n    str += String.fromCharCode(charCode);\n  }\n  const base64String = btoa(str);\n  return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\nfunction base64URLStringToBuffer(base64URLString) {\n  const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n  const padLength = (4 - base64.length % 4) % 4;\n  const padded = base64.padEnd(base64.length + padLength, '=');\n  const binary = atob(padded);\n  const buffer = new ArrayBuffer(binary.length);\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return buffer;\n}\nfunction browserSupportsWebAuthn() {\n  var _window;\n  return ((_window = window) === null || _window === void 0 ? void 0 : _window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function';\n}\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n  const {\n    id\n  } = descriptor;\n  return _objectSpread(_objectSpread({}, descriptor), {}, {\n    id: base64URLStringToBuffer(id),\n    transports: descriptor.transports\n  });\n}\nfunction isValidDomain(hostname) {\n  return hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname);\n}\nclass WebAuthnError extends Error {\n  constructor(_ref) {\n    let {\n      message,\n      code,\n      cause,\n      name\n    } = _ref;\n    super(message, {\n      cause\n    });\n    this.name = name !== null && name !== void 0 ? name : cause.name;\n    this.code = code;\n  }\n}\nfunction identifyRegistrationError(_ref2) {\n  let {\n    error,\n    options\n  } = _ref2;\n  const {\n    publicKey\n  } = options;\n  if (!publicKey) {\n    throw Error('options was missing required publicKey property');\n  }\n  if (error.name === 'AbortError') {\n    if (options.signal instanceof AbortSignal) {\n      return new WebAuthnError({\n        message: 'Registration ceremony was sent an abort signal',\n        code: 'ERROR_CEREMONY_ABORTED',\n        cause: error\n      });\n    }\n  } else if (error.name === 'ConstraintError') {\n    var _publicKey$authentica, _publicKey$authentica2;\n    if (((_publicKey$authentica = publicKey.authenticatorSelection) === null || _publicKey$authentica === void 0 ? void 0 : _publicKey$authentica.requireResidentKey) === true) {\n      return new WebAuthnError({\n        message: 'Discoverable credentials were required but no available authenticator supported it',\n        code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n        cause: error\n      });\n    } else if (((_publicKey$authentica2 = publicKey.authenticatorSelection) === null || _publicKey$authentica2 === void 0 ? void 0 : _publicKey$authentica2.userVerification) === 'required') {\n      return new WebAuthnError({\n        message: 'User verification was required but no available authenticator supported it',\n        code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n        cause: error\n      });\n    }\n  } else if (error.name === 'InvalidStateError') {\n    return new WebAuthnError({\n      message: 'The authenticator was previously registered',\n      code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n      cause: error\n    });\n  } else if (error.name === 'NotAllowedError') {\n    return new WebAuthnError({\n      message: error.message,\n      code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n      cause: error\n    });\n  } else if (error.name === 'NotSupportedError') {\n    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n    if (validPubKeyCredParams.length === 0) {\n      return new WebAuthnError({\n        message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n        code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n        cause: error\n      });\n    }\n    return new WebAuthnError({\n      message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n      code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n      cause: error\n    });\n  } else if (error.name === 'SecurityError') {\n    const effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError({\n        message: \"\".concat(window.location.hostname, \" is an invalid domain\"),\n        code: 'ERROR_INVALID_DOMAIN',\n        cause: error\n      });\n    } else if (publicKey.rp.id !== effectiveDomain) {\n      return new WebAuthnError({\n        message: \"The RP ID \\\"\".concat(publicKey.rp.id, \"\\\" is invalid for this domain\"),\n        code: 'ERROR_INVALID_RP_ID',\n        cause: error\n      });\n    }\n  } else if (error.name === 'TypeError') {\n    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n      return new WebAuthnError({\n        message: 'User ID was not between 1 and 64 characters',\n        code: 'ERROR_INVALID_USER_ID_LENGTH',\n        cause: error\n      });\n    }\n  } else if (error.name === 'UnknownError') {\n    return new WebAuthnError({\n      message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n      code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n      cause: error\n    });\n  }\n  return error;\n}\nclass BaseWebAuthnAbortService {\n  createNewAbortSignal() {\n    if (this.controller) {\n      const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n      abortError.name = 'AbortError';\n      this.controller.abort(abortError);\n    }\n    const newController = new AbortController();\n    this.controller = newController;\n    return newController.signal;\n  }\n  cancelCeremony() {\n    if (this.controller) {\n      const abortError = new Error('Manually cancelling existing WebAuthn API call');\n      abortError.name = 'AbortError';\n      this.controller.abort(abortError);\n      this.controller = undefined;\n    }\n  }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n  if (!attachment) {\n    return;\n  }\n  if (attachments.indexOf(attachment) < 0) {\n    return;\n  }\n  return attachment;\n}\nasync function startRegistration(optionsJSON) {\n  var _optionsJSON$excludeC;\n  if (!browserSupportsWebAuthn()) {\n    throw new Error('WebAuthn is not supported in this browser');\n  }\n  const publicKey = _objectSpread(_objectSpread({}, optionsJSON), {}, {\n    challenge: base64URLStringToBuffer(optionsJSON.challenge),\n    user: _objectSpread(_objectSpread({}, optionsJSON.user), {}, {\n      id: base64URLStringToBuffer(optionsJSON.user.id)\n    }),\n    excludeCredentials: (_optionsJSON$excludeC = optionsJSON.excludeCredentials) === null || _optionsJSON$excludeC === void 0 ? void 0 : _optionsJSON$excludeC.map(toPublicKeyCredentialDescriptor)\n  });\n  const options = {\n    publicKey\n  };\n  options.signal = WebAuthnAbortService.createNewAbortSignal();\n  let credential;\n  try {\n    credential = await navigator.credentials.create(options);\n  } catch (err) {\n    throw identifyRegistrationError({\n      error: err,\n      options\n    });\n  }\n  if (!credential) {\n    throw new Error('Registration was not completed');\n  }\n  const {\n    id,\n    rawId,\n    response,\n    type\n  } = credential;\n  let transports = undefined;\n  if (typeof response.getTransports === 'function') {\n    transports = response.getTransports();\n  }\n  let responsePublicKeyAlgorithm = undefined;\n  if (typeof response.getPublicKeyAlgorithm === 'function') {\n    try {\n      responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n    } catch (error) {\n      warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n    }\n  }\n  let responsePublicKey = undefined;\n  if (typeof response.getPublicKey === 'function') {\n    try {\n      const _publicKey = response.getPublicKey();\n      if (_publicKey !== null) {\n        responsePublicKey = bufferToBase64URLString(_publicKey);\n      }\n    } catch (error) {\n      warnOnBrokenImplementation('getPublicKey()', error);\n    }\n  }\n  let responseAuthenticatorData;\n  if (typeof response.getAuthenticatorData === 'function') {\n    try {\n      responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n    } catch (error) {\n      warnOnBrokenImplementation('getAuthenticatorData()', error);\n    }\n  }\n  return {\n    id,\n    rawId: bufferToBase64URLString(rawId),\n    response: {\n      attestationObject: bufferToBase64URLString(response.attestationObject),\n      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n      transports,\n      publicKeyAlgorithm: responsePublicKeyAlgorithm,\n      publicKey: responsePublicKey,\n      authenticatorData: responseAuthenticatorData\n    },\n    type,\n    clientExtensionResults: credential.getClientExtensionResults(),\n    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)\n  };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n  console.warn(\"The browser extension that intercepted this WebAuthn API call incorrectly implemented \".concat(methodName, \". You should report this error to them.\\n\"), cause);\n}\nfunction browserSupportsWebAuthnAutofill() {\n  if (!browserSupportsWebAuthn()) {\n    return new Promise(resolve => resolve(false));\n  }\n  const globalPublicKeyCredential = window.PublicKeyCredential;\n  if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n    return new Promise(resolve => resolve(false));\n  }\n  return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\nfunction identifyAuthenticationError(_ref3) {\n  let {\n    error,\n    options\n  } = _ref3;\n  const {\n    publicKey\n  } = options;\n  if (!publicKey) {\n    throw Error('options was missing required publicKey property');\n  }\n  if (error.name === 'AbortError') {\n    if (options.signal instanceof AbortSignal) {\n      return new WebAuthnError({\n        message: 'Authentication ceremony was sent an abort signal',\n        code: 'ERROR_CEREMONY_ABORTED',\n        cause: error\n      });\n    }\n  } else if (error.name === 'NotAllowedError') {\n    return new WebAuthnError({\n      message: error.message,\n      code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n      cause: error\n    });\n  } else if (error.name === 'SecurityError') {\n    const effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError({\n        message: \"\".concat(window.location.hostname, \" is an invalid domain\"),\n        code: 'ERROR_INVALID_DOMAIN',\n        cause: error\n      });\n    } else if (publicKey.rpId !== effectiveDomain) {\n      return new WebAuthnError({\n        message: \"The RP ID \\\"\".concat(publicKey.rpId, \"\\\" is invalid for this domain\"),\n        code: 'ERROR_INVALID_RP_ID',\n        cause: error\n      });\n    }\n  } else if (error.name === 'UnknownError') {\n    return new WebAuthnError({\n      message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n      code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n      cause: error\n    });\n  }\n  return error;\n}\nasync function startAuthentication(optionsJSON) {\n  var _optionsJSON$allowCre;\n  let useBrowserAutofill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!browserSupportsWebAuthn()) {\n    throw new Error('WebAuthn is not supported in this browser');\n  }\n  let allowCredentials;\n  if (((_optionsJSON$allowCre = optionsJSON.allowCredentials) === null || _optionsJSON$allowCre === void 0 ? void 0 : _optionsJSON$allowCre.length) !== 0) {\n    var _optionsJSON$allowCre2;\n    allowCredentials = (_optionsJSON$allowCre2 = optionsJSON.allowCredentials) === null || _optionsJSON$allowCre2 === void 0 ? void 0 : _optionsJSON$allowCre2.map(toPublicKeyCredentialDescriptor);\n  }\n  const publicKey = _objectSpread(_objectSpread({}, optionsJSON), {}, {\n    challenge: base64URLStringToBuffer(optionsJSON.challenge),\n    allowCredentials\n  });\n  const options = {};\n  if (useBrowserAutofill) {\n    if (!(await browserSupportsWebAuthnAutofill())) {\n      throw Error('Browser does not support WebAuthn autofill');\n    }\n    const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n    if (eligibleInputs.length < 1) {\n      throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n    }\n    options.mediation = 'conditional';\n    publicKey.allowCredentials = [];\n  }\n  options.publicKey = publicKey;\n  options.signal = WebAuthnAbortService.createNewAbortSignal();\n  let credential;\n  try {\n    credential = await navigator.credentials.get(options);\n  } catch (err) {\n    throw identifyAuthenticationError({\n      error: err,\n      options\n    });\n  }\n  if (!credential) {\n    throw new Error('Authentication was not completed');\n  }\n  const {\n    id,\n    rawId,\n    response,\n    type\n  } = credential;\n  let userHandle = undefined;\n  if (response.userHandle) {\n    userHandle = bufferToBase64URLString(response.userHandle);\n  }\n  return {\n    id,\n    rawId: bufferToBase64URLString(rawId),\n    response: {\n      authenticatorData: bufferToBase64URLString(response.authenticatorData),\n      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n      signature: bufferToBase64URLString(response.signature),\n      userHandle\n    },\n    type,\n    clientExtensionResults: credential.getClientExtensionResults(),\n    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)\n  };\n}\nfunction platformAuthenticatorIsAvailable() {\n  if (!browserSupportsWebAuthn()) {\n    return new Promise(resolve => resolve(false));\n  }\n  return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\nexport { WebAuthnAbortService, WebAuthnError, base64URLStringToBuffer, browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, bufferToBase64URLString, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };","map":{"version":3,"names":["bufferToBase64URLString","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","base64String","btoa","replace","base64URLStringToBuffer","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","browserSupportsWebAuthn","_window","window","PublicKeyCredential","undefined","toPublicKeyCredentialDescriptor","descriptor","id","_objectSpread","transports","isValidDomain","hostname","test","WebAuthnError","Error","constructor","_ref","message","code","cause","name","identifyRegistrationError","_ref2","error","options","publicKey","signal","AbortSignal","_publicKey$authentica","_publicKey$authentica2","authenticatorSelection","requireResidentKey","userVerification","validPubKeyCredParams","pubKeyCredParams","filter","param","type","effectiveDomain","location","concat","rp","user","byteLength","BaseWebAuthnAbortService","createNewAbortSignal","controller","abortError","abort","newController","AbortController","cancelCeremony","WebAuthnAbortService","attachments","toAuthenticatorAttachment","attachment","indexOf","startRegistration","optionsJSON","_optionsJSON$excludeC","challenge","excludeCredentials","map","credential","navigator","credentials","create","err","rawId","response","getTransports","responsePublicKeyAlgorithm","getPublicKeyAlgorithm","warnOnBrokenImplementation","responsePublicKey","getPublicKey","_publicKey","responseAuthenticatorData","getAuthenticatorData","attestationObject","clientDataJSON","publicKeyAlgorithm","authenticatorData","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","methodName","console","warn","browserSupportsWebAuthnAutofill","Promise","resolve","globalPublicKeyCredential","isConditionalMediationAvailable","identifyAuthenticationError","_ref3","rpId","startAuthentication","_optionsJSON$allowCre","useBrowserAutofill","arguments","allowCredentials","_optionsJSON$allowCre2","eligibleInputs","document","querySelectorAll","mediation","get","userHandle","signature","platformAuthenticatorIsAvailable","isUserVerifyingPlatformAuthenticatorAvailable"],"sources":["C:/Users/Admin/Desktop/enisi/frontend/node_modules/@simplewebauthn/browser/dist/bundle/index.js"],"sourcesContent":["/* [@simplewebauthn/browser@10.0.0] */\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return (window?.PublicKeyCredential !== undefined &&\n        typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        super(message, { cause });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nclass BaseWebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(optionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        user: {\n            ...optionsJSON.user,\n            id: base64URLStringToBuffer(optionsJSON.user.id),\n        },\n        excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n\nfunction browserSupportsWebAuthnAutofill() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    const globalPublicKeyCredential = window\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nasync function startAuthentication(optionsJSON, useBrowserAutofill = false) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (optionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToBase64URLString(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { WebAuthnAbortService, WebAuthnError, base64URLStringToBuffer, browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, bufferToBase64URLString, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}